<HTML>
<HEAD>
<TITLE>NAME</TITLE>
</HEAD>

<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<UL>

		<LI><A HREF="#CONSTRUCTOR">CONSTRUCTOR</A>
		<LI><A HREF="#METHODS">METHODS</A>
	</UL>

	<LI><A HREF="#ANY_ROUTINES">ANY ROUTINES</A>
	<LI><A HREF="#NOTES">NOTES</A>
	<LI><A HREF="#CONFIG_FORMAT">CONFIG FORMAT</A>
	<LI><A HREF="#BUGS">BUGS</A>
	<LI><A HREF="#SEE_ALSO">SEE ALSO</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
<PRE> 
</PRE>
<P>
Net::SC - модуль для выстраивания цепочек socks серверов, и передачи через
них данных.

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<PRE> 
</PRE>
<P>
<PRE> # CONNECT TO HOST
 # ----------------
</PRE>
<P>
<PRE> ...
 $self = new Net::SC(
                     Timeout         =&gt; ( $opt{'to'}  || 10      ),
                     Chain_Len       =&gt; ( $opt{'l'}   || 2       ),
                     Debug           =&gt; ( $opt{'d'}   || 0x04    ),
                     Log_File        =&gt; ( $opt{'lf'}  || undef   ),
                     Random_Chain    =&gt; ( $opt{'rnd'} || 0       ),
                     Auto_Save       =&gt; 1
                  );
</PRE>
<P>
<PRE> die unless ref $self;
</PRE>
<P>
<PRE> unless ( ( $rc = $self-&gt;connect( $host, $port ) ) == SOCKS_OKAY ) {
   print STDERR &quot;Can't connect to $host:$port [&quot;.( socks_error($rc) ).&quot;]\n&quot;;
   exit;
 }
</PRE>
<P>
<PRE> $sh = $self-&gt;sh;
</PRE>
<P>
<PRE> print $sh, &quot;Hello !!!\n&quot;;
 ...
 $self-&gt;close;
 ...
</PRE>
<P>
<PRE> #  BIND THE PORT
 # ---------------
 
 ...
 $self = new Net::SC(
                     Timeout         =&gt; ( $opt{'to'}  || 10      ),
                     Chain_len       =&gt; ( $opt{'l'}   || 2       ),
                     Debug           =&gt; ( $opt{'d'}   || 0x04    ),
                     Log_file        =&gt; ( $opt{'lf'}  || undef   ),
                     Random_chain    =&gt; ( $opt{'rnd'} || 0       ),
                     Auto_save       =&gt; 1
                  );
</PRE>
<P>
<PRE> die unless ref $self;
</PRE>
<P>
<PRE> unless ( ( $rc = $self-&gt;bind( $host, $port ) ) == SOCKS_OKAY ) {
   print STDERR &quot;Can't bind port [&quot;.( socks_error($rc) ).&quot;]\n&quot;;
   exit;
 }
</PRE>
<P>
<PRE> print STDOUT &quot;Binding the port : &quot;,
               $self-&gt;socks_param('listen_port'), &quot;\n&quot;;
 print STDOUT &quot;     in the host : &quot;,
               $self-&gt;socks_param('listen_addr'), &quot;\n&quot;;
 print STDOUT &quot;     for $host\n&quot;;
        
 $self-&gt;configure( TIMEOUT =&gt; 45 );
 unless ( ( $rc = $self-&gt;accept() ) == SOCKS_OKAY ) {
        return $rc;
 } else {
   $sh = $self-&gt;sh;
 }
 
 print STDOUT 'Connect from: ',
                        $self-&gt;socks_param('listen_addr'), ':',
                        $self-&gt;socks_param('listen_port'), &quot;\n&quot;;
</PRE>
<P>
<PRE> print $sh 'Hello : ', $self-&gt;socks_param('listen_addr'), &quot;\n&quot;;
 print $sh ' port : ', $self-&gt;socks_param('listen_port'), &quot;\n&quot;;
</PRE>
<P>
<PRE> print STDOUT &lt;$sh&gt;;
 ...
 
Более детально все показано в примерах.
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
<PRE> 
</PRE>
<P>
<HR>
<H2><A NAME="CONSTRUCTOR">CONSTRUCTOR</A></H2>
<P>
<PRE> 
</PRE>
<DL>
<DT><STRONG><A NAME="item_new">new</A></STRONG><DD>
<P>
<PRE> 
</PRE>
<P>
Инициализация внутренних переменных. В качестве параметров принимает хеш,
со следующими ключами:

<P>
<PRE> TIMEOUT       - таймаут при создании цепочки, в секундах.
</PRE>
<P>
<PRE> CHAIN_LEN     - длина цепочки.
</PRE>
<P>
<PRE> DEBUG         - уровень отладки ( 0x00 | 0x01 | 0x02 | 0x04 )
                 0x00 - выключить
                 0x01 - включить
                 0x02 - выводить все ответы от sokcs серверов
                 0x04 - выводить все, что пишем socks'ам
                 0x08 - расширенная информация об ошибках
</PRE>
<P>
<PRE> CHAIN_FILE    - имя файла конфигурации.
</PRE>
<P>
<PRE> SYSLOG        - Если не undef то логи ведутся syslogd. Ключ
                 может принимать значения 'unix' или 'inet', т.е.
                 тип соединения с syslogd. По умолчанию undef.
</PRE>
<P>
<PRE> LOG_FILE      - имя лог файла, если undef то все пишем в STDERR
                 или передается syslogd.
</PRE>
<P>
<PRE> RANDOM_CHAIN  - правило построения цепочки ( 0 || 1 ).
                 0 - строить цепочку по порядку указанному в конфиге
                 1 - строить цепочку в произвольном порядке.
</PRE>
<P>
<PRE> CHECK_DELAY   - время в секундах, после которого при не удачной
                 попытке коннекта к серверу, его имя не будет
                 использовано при следующем создании цепочки.
</PRE>
<P>
<PRE> AUTO_SAVE     - автоматически записывать данные о socks серверах
                 в .db файл. Для более быстрого последующего коннекта.
</PRE>
<P>
<PRE> LOG_FH        - Файловый дескриптор для LOG файла. Используется только
                 если  LOG_FILE == undef
</PRE>
<P>
<PRE> LOOP_CONNECT - Прежде чем строить цепь дальше сервер коннектиться сам
                себе.
                0x01 - распространяется на socks v4
                0x02 - распространяется на socks v5
</PRE>
<P>
<PRE> RESTORY_TYPE - При установке в 1 данные из кэша об отсутствующих 
                машинах в файле конфигурации удаляются.
</PRE>
</DL>
<P>
<HR>
<H2><A NAME="METHODS">METHODS</A></H2>
<P>
<PRE> 
</PRE>
<DL>
<DT><STRONG><A NAME="item_connect">connect</A></STRONG><DD>
<P>
Создает соединение с удаленной машиной.

<P>
<PRE> Использование:
</PRE>
<P>
<PRE>  die unless $self-&gt;connect( $host, $port ) == SOCKS_OKAY;
</PRE>
<DT><STRONG><A NAME="item_bind">bind</A></STRONG><DD>
<P>
Создает соединение с socks сервером для соединения с ним. 

<P>
<PRE> Использование:
</PRE>
<P>
<PRE>  die unless $self-&gt;bind( $host, $port ) == SOCKS_OKAY;
</PRE>
<DT><STRONG><A NAME="item_accept">accept</A></STRONG><DD>
<P>
Ожидает соединение к соксу из вне... 

<P>
<PRE> Использование:
</PRE>
<P>
<PRE>  die unless $self-&gt;accept() == SOCKS_OKAY;
  $sh = $self-&gt;sh;
</PRE>
<DT><STRONG><A NAME="item_sh">sh</A></STRONG><DD>
<P>
Возвращает сок хандле... Использование:

<P>
<PRE>  $sh = $self-&gt;sh;
</PRE>
<DT><STRONG><A NAME="item_close">close</A></STRONG><DD>
<P>
Закрывает соединение через цепочку socks серверов...

<P>
<PRE> Использование:
</PRE>
<P>
<PRE>  $self-&gt;close;
</PRE>
<DT><STRONG><A NAME="item_configure">configure</A></STRONG><DD>
<P>
Изменить/прочитать текущие значения ( инициализируются при создании
<CODE>new()</CODE> ).

<P>
<PRE> Использование:
</PRE>
<P>
<PRE>  $self-&gt;configure( TIMEOUT =&gt; 10 );
</PRE>
<P>
<PRE>  первый аргумент - секция ( TIMEOUT, DEBUG, CHAIN_LEN, etc )
  второй аргумент - новое значение. ( не обязательно )
</PRE>
<DT><STRONG><A NAME="item_socks_param">socks_param</A></STRONG><DD>
<P>
Возвращает параметры последнего socks сервера в цепочке, такие как
listen_port, listen_addr, etc...

<P>
<PRE> Использование:
</PRE>
<P>
<PRE>  $listen_addr = $self-&gt;socks_param( 'listen_Addr' );
</PRE>
<P>
<PRE>  $all_param = $self-&gt;socks_param();
  $listen_addr = $all_param-&gt;{'listen_addr'};
</PRE>
</DL>
<P>
<HR>
<H1><A NAME="ANY_ROUTINES">ANY ROUTINES</A></H1>
<P>
<PRE> 
</PRE>
<P>
<PRE>    socks_error( ERROR_CODE ) 
</PRE>
<P>
<PRE>    Возвращает сообщение об ошибке по его коду.
</PRE>
<P>
<PRE>    Коды возврата socks'а :
</PRE>
<P>
<PRE>    SOCKS_GENERAL_SOCKS_SERVER_FAILURE
    SOCKS_CONNECTION_NOT_ALLOWED_BY_RUL
    SOCKS_NETWORK_UNREACHABLE
    SOCKS_HOST_UNREACHABLE
    SOCKS_CONNECTION_REFUSED
    SOCKS_TTL_EXPIRED
    SOCKS_COMMAND_NOT_SUPPORTED
    SOCKS_ADDRESS_TYPE_NOT_SUPPORTED
    SOCKS_OKAY
    SOCKS_FAILED
    SOCKS_NO_IDENT
    SOCKS_USER_MISMATCH
    SOCKS_INCOMPLETE_AUTH
    SOCKS_BAD_AUTH
    SOCKS_SERVER_DENIES_AUTH_METHOD
    SOCKS_MISSING_SOCKS_SERVER_NET_DATA
    SOCKS_MISSING_PEER_NET_DATA
    SOCKS_SOCKS_SERVER_UNAVAILABLE
    SOCKS_TIMEOUT
    SOCKS_UNSUPPORTED_PROTOCOL_VERSION
    SOCKS_UNSUPPORTED_ADDRESS_TYPE
    SOCKS_HOSTNAME_LOOKUP_FAILURE
</PRE>
<P>
<PRE>    $self-&gt;get_socks_count
</PRE>
<P>
<PRE>     Возвращает число socks серверов которые могут быть
     использованы для построения цепочки. Без учета находящихся
     в данный момент в дауне. 
</PRE>
<P>
<PRE>    $self-&gt;mark_proxy ( $proxy_id, $status );
</PRE>
<P>
<PRE>     Помечает прокси с порядковым номером в конфиге $id как временно 
     недоступный - если $status != SOCKS_OKAY, иначе очищает счетчик
     неудачных попыток...
</PRE>
<P>
<PRE>    $self-&gt;dump_cfg_data();
</PRE>
<P>
<PRE>     Сбрасывает текущее состояние всех серверов в ${CHAIN_FILE}.db
     файл. Имеет смысл пользовать при большом списке соксов, многие
     из которых часто дохнут... При Auto_Save данные сбрасываются
     автоматически после каждого bind или connect.
</PRE>
<P>
<PRE>    $self-&gt;restore_cfg_data();
</PRE>
<P>
<PRE>     Восстанавливает значения таймаутов... Восстанавливаются
     значения только для тех серверов которые прописаны в текущем
     конфиге. Т.е. если конфиг пустой то ни чего не восстановится.
     При установленной переменной $Net::SC::RESTORE_TYPE в 1 данные
     из кеша удаляются, если в файле конфигурации не присутствует
     больше данный Socks сервер.
</PRE>
<P>
<HR>
<H1><A NAME="NOTES">NOTES</A></H1>
<P>
<PRE> 
</PRE>
<P>
accept изменяет следующие значения возвращаемые socks_param:

<P>
<PRE> listen_addr - IP адрес удаленной машины
 listen_port - номер порта удаленной машины
</PRE>
<P>
Процедуры connect, bind, accept, при успешном завершении должны возвращать
SOCKS_OKAY

<P>
<HR>
<H1><A NAME="CONFIG_FORMAT">CONFIG FORMAT</A></H1>
<P>
<PRE> 
</PRE>
<P>
<PRE> #host           :   port    : uid   :   pswd    : socks_proto
 192.168.1.90    :   1080    :       :           :   5
 ...
</PRE>
<P>
<PRE> Коментари  - строки начинающиеся на `#', строки из одних
 пробелов игнорируются.
</PRE>
<P>
<HR>
<H1><A NAME="BUGS">BUGS</A></H1>
<P>
<PRE> 
</PRE>
<P>
При использовании на сервере ( socks v5 ) правил доступа для юзеров, т.е.
Васе можно на яндекс, а Вере на гугль, и запросе Васи к гуглю такая
ситуация не обрабатывается в create_chain, считается, что прокся жива, но
выдается честный SOCKS_CONNECTION_NOT_ALLOWED_BY_RULESET, поэтому если надо
ловите такие ситуации сами, и с помощью <CODE>mark_proxy()</CODE> помечайте
сервер как недоступный...

<P>
В инете встречаются 'нехорошие' соксы которые вроде как есть, но не
работают, поэтому например при коннекте к такому соксу v4 и длине цепочки
равной 1, построение закончится неудачно даже если в конфиге еще остался
список резервных серверов, для предотвращения этого можно попробовать
пользоваться Loop_Connect - к каждому серверу в цепи коннектимся дважды,
причем второй раз `через самого себя', что дает возможность проверить
сервер...

<P>
Loop_Connect также полезен в том смысле, что если коннекты через сервер
запрещены, то помечается как плохой следующий в цепи, ну и чтоб
предотвратить это...

<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
<PRE> 
</PRE>
<P>
perl, RFC 1928, RFC 1929, ...

<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
<PRE> 
</PRE>
<P>
<PRE> Okunev Igor V.  <A HREF="mailto:igor@prv.mts-nn.ru">mailto:igor@prv.mts-nn.ru</A>
                 <A HREF="http://www.mts-nn.ru/~gosha">http://www.mts-nn.ru/~gosha</A>
                                 icq:106183300
</PRE>
</BODY>

</HTML>
